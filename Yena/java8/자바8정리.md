# 1장
# 함수형 인터페이스와 람다 표현식
## 함수형 인터페이스
-	추상 인터페이스가 하나만 있으면 그게 함수형 인터페이스
-	Abstract 생략 가능
-	인터페이스임에도 system.out.println 사용가능
-	Default도 사용 가능
-	다른 형태의 메소드가 있어도 추상인터페이스가 하나면 함수형 인터페이스
-	@FuntionalInterface라고 정의하면 좀더 견고하게 관리할 수 있다
## 람다 표현식
-	Ctrl+Shit+I -> 람다식으로 간축시켜줌
- 코드를 줄일 수 있다.
- 메소드 매개변수, 리턴 타입, 변수로 만들어 사용할 수 있다.

## 자바에서 함수형 프로그래밍
- 함수를 First class Object로 사용할 수 있다.
- 순수 함수 
    - 함수 밖에 있는 값을 변경하지 않는다.
    - 상태가 없다(밖의 값을 참조해서쓰는 경우)
    - 순수함수
    - ![alt](사진\\good-doit.JPG)
    - 외부 값 참조
    - ![alt](사진\\bad-doit.JPG)
    - 외부 값 변경
    - ![alt](사진\\bad-doit2.JPG)
- 고차 함수 
    - 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수 도 있다.

# 자바에서 제공하는 함수형 인터페이스
- 자바에서 기본으로 제공하는 함수형 인터페이스
    - Function<T,R>
        - T와 R로 정의되어있고 R을 구현하면 됨
        - T타입을 받아서 R타입을 리턴하는 함수 인터페이스
        - 함수 조함용 메소드
            - andThen  - 인자를 나중에 적용함 
            - compose- 입력값을 가지고 인자를 먼저 적용함
        - ![alt](사진\\Function-ex.JPG)
    - BiFunction<T,U,R>
      - 두개의 값(T, U)를 받아서 R 타입을 리턴하는 함수 인터페이스
        - R apply(T t, U u)
    - Consumer<T>
      - 받기만하고 아무것도 리턴하지않는 함수 인터페이스
        - void Accept(T t)
      - 함수 조합용 메소드
        - andThen
    - Suppler<T>
      - 받아올 값을 정의함
        - T get()
     - ![alt](사진\\Consumer,Supplier.JPG)
    - Predicate
      - 인자 하나를 받아서 T,F를 리턴
        - boolean test(T t)
     - ![alt](사진\\predicate.JPG)

    - UnaryOperator<T>
      - 입력값이 하나, 동일한 타입 리턴
        - And
        - Or
        - Negate

# 람다 표현식
## 람다
- 인자리스트 -> {바디}

## 인자 리스트
- 인자가 없을때 :()
- 인자가 하나일때 : (one)/ one
- 인자 여러개일 때: (one, two)
- 인자의 타입은 생략가능, 컴파일러가 추론하지만 명시도 가능 : (integer one, Integer two)

## 바디
- 화살표 오른쪽에 함수 본문 정의
- 여러줄인 경우 {} 사용
- 한줄인 경우 생략가능 . Return도 생략 가능

## 변수 캡쳐
### 로컬 변수 캡쳐 
 -  final이거나 effective final(값 변경 안되서 final로 컴파일러가 간주함) 인 경우만 참조.
 -  쉐도잉
    -  foo안에 run안의 local, 람다, 익명 클래스가 있으면 로컬과 익명클래스는 쉐도잉이되고 람다는 안됨.
    -	 이름하고 같은 변수가 있으면 가려짐(쉐도잉)
    -	람다는 람다를 감싸는 scope이 같아서 쉐도잉이 안됨
    ![alt](사진\\쉐도잉.JPG)

# 메서드 레퍼런스

- 메소드를 참조하는 방법
  - 스태틱 메소드 참조 -> 타입:: 스태틱 메소드
  - 특정 객체의 인스턴스 메소드 참조 -> 객체 레퍼런스 ::인스턴스 메소드
  - 임의 객체의 인스턴스 메소드 참조 -> 타입:: 인스턴스 메소드
  - 생성자 참조 -> 타입:: new

![alt](사진\\메소드참조.JPG)
- 임의 객체 인스턴스 메소드 참조 예시(-	특정타입의 불특정다수 인스턴스의 특정 엑서스 메서드 참조하는 방법)
![alt](사진\\불특정.JPG)

# 2장 인터페이스 변화
# 인터페이스 기본 메소드와 스테틱 메소드

## 기본 메소드
-  인터페이스에 메소드 선언이 아니라 구현체를 제공하는 방법
-  해당 인터페이스를 구현한 클래스를 깨트리지 않고 새 기능을 추가할 수 있다.
-  ![alt](사진\\인터페이스상속.JPG)
-  인터페이스와 그걸 구현하는 클래스를 생성하였는데 나중에 인터페이스에 새로운 메소드가 추가된다면 제대로 동작한다고 보장할 수 없음. 
-  구현체가 모르게 추가한 기능으로 그만큼 리스크가 있다 
   -  반드시 문서화할 것 (@implSpec)

- 본인이 수정할 수 있는 인타페이스에만 기본 메소드를 제공할 수 있다.
- 인터페이스를 상속받는 인터페이스에서 기본 메소드를 제공할 수 있다.
- 인터페이스 구현체가 재정의할 수 있다. 
- 그러나 object가 제공하는 기능은 기본메소드를 제공할 수는 없다.(equals, hasCode,,)
- ![alt](사진\\재정의.JPG)
- 
## 스태틱 메소드
  - 해당 타입 관한 헬터, 또는 유틸리티 메소드를 제공할 때 인터페이스에 스태틱 메소드를 제공할 수 있다. 

# 자바8 API의 기본 메소드와 스태틱 메소드
  ## Iterable의 기본 메소드
  - forEach()
  - spliterator()
  - ![alt](사진\\literable.JPG)
  - ![alt](사진\\list2.JPG)
  ## Collection의 기본 메소드
  - stream() / parallelStream()
  - removeIf(Predicate)
  - spliterator()
## Comparator의 기본 메소드 및 스태틱 메소드
- reversed()
- thenComparing()
- static reverseOrder() / naturalOrder()
- static nullsFirst() / nullsLast()
- static comparing()
- ![alt](사진\\comparator.JPG)

# 스트림 API 소개 
-	데이터를 담는 저장소가 아님
-	데이터를 소스로 사용해서 어떤 처리를 하는 것
-	Funtional하다. -> 소스를 변경하지 않는다.
-	중계 오퍼레이터(레이지하다 ), 터미널 오퍼레이터로 나눌 수 있다
-	병렬처리가 쉽다.

## 스트림 파이프라인
- 0 또는 다수의 중개 오퍼레이션 (intermediate operation)과 한개의 종료 오퍼레이션
(terminal operation)으로 구성한다.
-  스트림의 데이터 소스는 오직 터미널 오퍼네이션을 실행할 때에만 처리한다
 ## 중계 오처레이션
 - Stream을 리턴한다.
 - filter, map, limit, skip, sorted, ..
 ## 터미널 오퍼레이션
 - Stream을 리턴하지 않는다.
- collect, allMatch, count, forEach, min, max, ...
- ![alt](사진\\중계종료.JPG)

# 스프링 API
## 걸러내기
- Filter(Predicate)
- 예) 이름이 3글자 이상인 데이터만 새로운 스트림으로
  
## 변형하기
- Map(Function) 또는 FlatMap(Function)
- 예) List<Stream<String>>을 String의 스트림으로

## 생성하기
- generate(Supplier) 또는 Iterate(T seed, UnaryOperator)
- 예) 10부터 1씩 증가하는 무제한 숫자 스트림

## 제한하기
- limit(long) 또는 skip(long)
- 예) 최대 5개의 요소가 담긴 스트림을 리턴
- ![alt](사진\\collection으로.JPG)
## 스트림에 있는 데이터가 특정 조건을 만족하는지 확인
- anyMatch(), allMatch(),nonMatch()
- 스트림에 있는 모든 값이 10보다 작은지 확인

## 개수 세기
- count()
- 예) 10보다 큰 수의 개수를 센다.

## 스트림을 데이터 하나로 뭉치기
- reduce(identity, BiFunction), collect(), sum(), max()
- 예) 모든 숫자 합 구하기
-  ![alt](사진\\javaclass.JPG)

# Optional

# Optional 소개
- NullPointException을 자주 보는 이유
  -> null을 리턴하고 && null 체크를 잊어서
  - 메소드에서 값을 제대로 리턴할 수 없는 경우 할 수 있는 방법
    - 예외를 던진다
    - null을 리턴한다
    - Optinal을 리턴한다.

 ![alt](사진\\optional.JPG)

- 	리턴할 게없다고 null을 리턴하지 말고 Optinal.empy()을 써라
 

## Optinal
- 오직 값 한개가 들어있을 수도 있는 컨테이너
- Of: 오는 값 무조건 null 아님
-	Ofnullable: 널일 수 있는 값이 옴
- 주의
  - 리턴값으로만 쓰기 권장(메소드 매개변수타입, 맵의 키 타입, 인스턴스 필드 타입으로 쓰지 말자)
  - Optinal을 리턴하는 메소드에서 null을 리턴하지 말자
  - Collection, Map, Stream Array, Opinal은 이미 null을 포함히므로 Optinal로 감싸지 말 것

### Optional에 값이 있는지 없는지 확인하기
- isPresent()
- isEmpty() (Java 11부터 제공)

### Optional에 있는 값 가져오기
- get() --->되도록 아래 함수 쓰기
- ifPresent(Consumer): 값있으면 ~리턴
- orElse(T): 값 있으면 리턴 없으면 ~리턴
- orElseGet(Suppler): 없으면 새로 만듬
- orElseThrow: 값없으면 에러 던짐
  
### 값 걸러내기
- Optinal map(Predicate)

### Optional 값 변환하기
- Optional map(Function)
- Optional flatMap(Function) : Optional 안에 들어있는 인스턴스가 Optional인 경우에
사용하면 편리 
 ![alt](사진\\optinal-ex.JPG)


# Date 와  Time
## 새로운 날짜 API가 생긴 이유
- 이전에는 thread safe하지않고 버그 발생여지가 많다.
 ![alt](사진\\date.JPG)

## 자바 8에서 제공하는 Date-Time API
  - clear
  - Fluent
  - Immutable
  - Extensible
### 지금 이순간을 표현하는 법
- Instant.now(): 현재 UTC (GMT)를 리턴한다.
- Universal Time Coordinated == Greenwich Mean Time
![alt](사진\\instant.JPG)


### 인류용 일시 표현하는 법
- LocalDateTime.now(): 현재 시스템 Zone에 해당하는(로컬) 일시를 리턴한다.
- LocalDateTime.of(int, Month, int, int, int, int): 로컬의 특정 일시를 리턴한다.
- ZonedDateTime.of(int, Month, int, int, int, int, ZoneId): 특정 Zone의 특정 일시를
리턴한다.
 ![alt](사진\\localdatetime.JPG)

### 기간을 표현하는 방법
- Period / Duration . beteen()
 ![alt](사진\\기간.JPG)

### 파싱 또는 포메팅
- LocalDateTime.parse(String, DateTimeFormatter);
- Dateteme
  ![alt](사진\\time형태.JPG)


# 자바 Concurrent 프로그래밍
## Concurrent 소프트웨어
- 동시에 여러 작업을 할 수 있는 소프트웨어
## 자바에서 지원하는 컨커런트
- 멀티 프로세싱
- 멀티쓰레드

## 쓰레드 만드는 두가지 방법
 ![alt](사진\\thread1.JPG)
![alt](사진\\thread2.JPG)
  ## 쓰레드 주요 기능
- 현재 쓰레드 멈춰두기 (sleep): 다른 쓰레드가 처리할 수 있도록 기회를 주지만 그렇다고
락을 놔주진 않음
![alt](사진\\sleep.JPG)
- 다른 쓰레드 깨우기 (interupt): 다른 쓰레드를 깨워서 interruptedExeption을 발생 시킴
있고.
- 다른 쓰레드 기다리기 (join): 다른 쓰레드가 끝날 때까지 기다린다.
- ![alt](사진\\join.JPG)


# Executor
## Executor가 하는 일
- 애플리케이션이 사용할 쓰레드 풀을 만들어 관리.
- 쓰레드 관리: 쓰레드 생명 주기를 관리한다.
- 작업 처리 및 실행: 쓰레드로 실행할 작업을 제공할 수 있는 API를 제공
-	쓰레드를 만들어 주기에 Runable만 만들면 됨
-	executor보단 executorService,를 더 많이 사용

## 주요 인터페이스
- Executor: execute(Runnable)
- ExecutorService: Executor 상속 받은 인터페이스로, Callable도 실행할 수 있으며,
Executor를 종료 시키거나, 여러 Callable을 동시에 실행하는 등의 기능을 제공.
- ScheduledExecutorService: ExecutorService를 상속 받은 인터페이스로 특정 시간
이후에 또는 주기적으로 작업을 실행할 수 있음.
![alt](사진\\executor.JPG)

# Callable과 Future
### Collable
-	러너블과 거의 같지만 리턴값을 가진다는 차이점 있음
### Future
- 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있음

### 결과를 가져오기 get()
- 블록킹 콜이다.
- 타임아웃(최대한으로 기다릴 시간)을 설정할 수 있음
### 작업 상태 확인하기 isDone()
- 완료 했으면 true 아니면 false를 리턴
### 작업 취소하기 cancel()
- 취소 했으면 true 못했으면 false를 리턴한다.
- parameter로 true를 전달하면 현재 진행중인 쓰레드를 interrupt하고 그러지 않으면 현재
진행중인 작업이 끝날때까지 기다림
### 여러 작업 동시에 실행하기 invokeAll()
- 동시에 실행한 작업 중에 제일 오래 걸리는 작업 만큼 시간이 걸림
### 여러작업 중에 하나라도 먼저 응답이 오면 끝내기 invokeAny()
-동시에 실행한 작업 중에 제일 짧게 걸리는 작업 만큼 시간이 걸림
- 블록킹 콜

![alt](사진\\collable.JPG)

# CompletableFuture
- 비동기(Asynchronous) 프로그래밍을 가능케하는 인터페이스

## Future로는 하기 어렵던 작업들
- Future를 외부에서 완료 시킬 수 없음
- 블로킹 코드(get())를 사용하지 않고 다른 작업x
- 여러 Future를 조합할 수 없음
- 예외 처리용 API를 제공하지 않음.

## CompletableFuture
- Implements Future
- Implements CompletionStage
## 비동기로 작업 실행하기
- 리턴값이 없는 경우: runAsync()
- 리턴값이 있는 경우: supplyAsync()

![alt](사진\\asnc.JPG)
## 콜백 제공하기
- thenApply(Function): 리턴값을 받아서 다른 값으로 바꾸는 콜백
-  thenAccept(Consumer): 리턴값을 또 다른 작업을 처리하는 콜백 (리턴없이)
- thenRun(Runnable): 리턴값 받지 다른 작업을 처리하는 콜백
- 콜백 자체를 또 다른 쓰레드에서 실행할 수 있다.
- ![alt](사진\\runAsnc.JPG)